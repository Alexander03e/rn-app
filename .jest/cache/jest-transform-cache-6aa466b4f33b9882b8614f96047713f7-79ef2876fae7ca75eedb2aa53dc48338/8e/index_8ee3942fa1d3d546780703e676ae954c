7c266161c7357ba43e4f1bb112cbc9a0
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
exports.default = exports.TestEnvironment = void 0;
function _vm() {
  const data = require('vm');
  _vm = function () {
    return data;
  };
  return data;
}
function _fakeTimers() {
  const data = require('@jest/fake-timers');
  _fakeTimers = function () {
    return data;
  };
  return data;
}
function _jestMock() {
  const data = require('jest-mock');
  _jestMock = function () {
    return data;
  };
  return data;
}
function _jestUtil() {
  const data = require('jest-util');
  _jestUtil = function () {
    return data;
  };
  return data;
}
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

// some globals we do not want, either because deprecated or we set it ourselves
const denyList = new Set(['GLOBAL', 'root', 'global', 'globalThis', 'Buffer', 'ArrayBuffer', 'Uint8Array',
// if env is loaded within a jest test
'jest-symbol-do-not-touch']);
const nodeGlobals = new Map(Object.getOwnPropertyNames(globalThis).filter(global => !denyList.has(global)).map(nodeGlobalsKey => {
  const descriptor = Object.getOwnPropertyDescriptor(globalThis, nodeGlobalsKey);
  if (!descriptor) {
    throw new Error(`No property descriptor for ${nodeGlobalsKey}, this is a bug in Jest.`);
  }
  return [nodeGlobalsKey, descriptor];
}));
function isString(value) {
  return typeof value === 'string';
}
class NodeEnvironment {
  context;
  fakeTimers;
  fakeTimersModern;
  global;
  moduleMocker;
  customExportConditions = ['node', 'node-addons'];
  _configuredExportConditions;

  // while `context` is unused, it should always be passed
  constructor(config, _context) {
    const {
      projectConfig
    } = config;
    this.context = (0, _vm().createContext)();
    const global = (0, _vm().runInContext)('this', Object.assign(this.context, projectConfig.testEnvironmentOptions));
    this.global = global;
    const contextGlobals = new Set(Object.getOwnPropertyNames(global));
    for (const [nodeGlobalsKey, descriptor] of nodeGlobals) {
      if (!contextGlobals.has(nodeGlobalsKey)) {
        if (descriptor.configurable) {
          Object.defineProperty(global, nodeGlobalsKey, {
            configurable: true,
            enumerable: descriptor.enumerable,
            get() {
              const value = globalThis[nodeGlobalsKey];

              // override lazy getter
              Object.defineProperty(global, nodeGlobalsKey, {
                configurable: true,
                enumerable: descriptor.enumerable,
                value,
                writable: true
              });
              return value;
            },
            set(value) {
              // override lazy getter
              Object.defineProperty(global, nodeGlobalsKey, {
                configurable: true,
                enumerable: descriptor.enumerable,
                value,
                writable: true
              });
            }
          });
        } else if ('value' in descriptor) {
          Object.defineProperty(global, nodeGlobalsKey, {
            configurable: false,
            enumerable: descriptor.enumerable,
            value: descriptor.value,
            writable: descriptor.writable
          });
        } else {
          Object.defineProperty(global, nodeGlobalsKey, {
            configurable: false,
            enumerable: descriptor.enumerable,
            get: descriptor.get,
            set: descriptor.set
          });
        }
      }
    }

    // @ts-expect-error - Buffer and gc is "missing"
    global.global = global;
    global.Buffer = Buffer;
    global.ArrayBuffer = ArrayBuffer;
    // TextEncoder (global or via 'util') references a Uint8Array constructor
    // different than the global one used by users in tests. This makes sure the
    // same constructor is referenced by both.
    global.Uint8Array = Uint8Array;
    (0, _jestUtil().installCommonGlobals)(global, projectConfig.globals);

    // Node's error-message stack size is limited at 10, but it's pretty useful
    // to see more than that when a test fails.
    global.Error.stackTraceLimit = 100;
    if ('customExportConditions' in projectConfig.testEnvironmentOptions) {
      const {
        customExportConditions
      } = projectConfig.testEnvironmentOptions;
      if (Array.isArray(customExportConditions) && customExportConditions.every(isString)) {
        this._configuredExportConditions = customExportConditions;
      } else {
        throw new Error('Custom export conditions specified but they are not an array of strings');
      }
    }
    this.moduleMocker = new (_jestMock().ModuleMocker)(global);
    const timerIdToRef = id => ({
      id,
      ref() {
        return this;
      },
      unref() {
        return this;
      }
    });
    const timerRefToId = timer => timer?.id;
    this.fakeTimers = new (_fakeTimers().LegacyFakeTimers)({
      config: projectConfig,
      global,
      moduleMocker: this.moduleMocker,
      timerConfig: {
        idToRef: timerIdToRef,
        refToId: timerRefToId
      }
    });
    this.fakeTimersModern = new (_fakeTimers().ModernFakeTimers)({
      config: projectConfig,
      global
    });
  }

  // eslint-disable-next-line @typescript-eslint/no-empty-function
  async setup() {}
  async teardown() {
    if (this.fakeTimers) {
      this.fakeTimers.dispose();
    }
    if (this.fakeTimersModern) {
      this.fakeTimersModern.dispose();
    }
    this.context = null;
    this.fakeTimers = null;
    this.fakeTimersModern = null;
  }
  exportConditions() {
    return this._configuredExportConditions ?? this.customExportConditions;
  }
  getVmContext() {
    return this.context;
  }
}
exports.default = NodeEnvironment;
const TestEnvironment = NodeEnvironment;
exports.TestEnvironment = TestEnvironment;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImRlZmF1bHQiLCJUZXN0RW52aXJvbm1lbnQiLCJfdm0iLCJkYXRhIiwicmVxdWlyZSIsIl9mYWtlVGltZXJzIiwiX2plc3RNb2NrIiwiX2plc3RVdGlsIiwiZGVueUxpc3QiLCJTZXQiLCJub2RlR2xvYmFscyIsIk1hcCIsImdldE93blByb3BlcnR5TmFtZXMiLCJnbG9iYWxUaGlzIiwiZmlsdGVyIiwiZ2xvYmFsIiwiaGFzIiwibWFwIiwibm9kZUdsb2JhbHNLZXkiLCJkZXNjcmlwdG9yIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiRXJyb3IiLCJpc1N0cmluZyIsIk5vZGVFbnZpcm9ubWVudCIsImNvbnRleHQiLCJmYWtlVGltZXJzIiwiZmFrZVRpbWVyc01vZGVybiIsIm1vZHVsZU1vY2tlciIsImN1c3RvbUV4cG9ydENvbmRpdGlvbnMiLCJfY29uZmlndXJlZEV4cG9ydENvbmRpdGlvbnMiLCJjb25zdHJ1Y3RvciIsImNvbmZpZyIsIl9jb250ZXh0IiwicHJvamVjdENvbmZpZyIsImNyZWF0ZUNvbnRleHQiLCJydW5JbkNvbnRleHQiLCJhc3NpZ24iLCJ0ZXN0RW52aXJvbm1lbnRPcHRpb25zIiwiY29udGV4dEdsb2JhbHMiLCJjb25maWd1cmFibGUiLCJlbnVtZXJhYmxlIiwiZ2V0Iiwid3JpdGFibGUiLCJzZXQiLCJCdWZmZXIiLCJBcnJheUJ1ZmZlciIsIlVpbnQ4QXJyYXkiLCJpbnN0YWxsQ29tbW9uR2xvYmFscyIsImdsb2JhbHMiLCJzdGFja1RyYWNlTGltaXQiLCJBcnJheSIsImlzQXJyYXkiLCJldmVyeSIsIk1vZHVsZU1vY2tlciIsInRpbWVySWRUb1JlZiIsImlkIiwicmVmIiwidW5yZWYiLCJ0aW1lclJlZlRvSWQiLCJ0aW1lciIsIkxlZ2FjeUZha2VUaW1lcnMiLCJ0aW1lckNvbmZpZyIsImlkVG9SZWYiLCJyZWZUb0lkIiwiTW9kZXJuRmFrZVRpbWVycyIsInNldHVwIiwidGVhcmRvd24iLCJkaXNwb3NlIiwiZXhwb3J0Q29uZGl0aW9ucyIsImdldFZtQ29udGV4dCJdLCJzb3VyY2VzIjpbImluZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBleHBvcnRzLlRlc3RFbnZpcm9ubWVudCA9IHZvaWQgMDtcbmZ1bmN0aW9uIF92bSgpIHtcbiAgY29uc3QgZGF0YSA9IHJlcXVpcmUoJ3ZtJyk7XG4gIF92bSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZGF0YTtcbiAgfTtcbiAgcmV0dXJuIGRhdGE7XG59XG5mdW5jdGlvbiBfZmFrZVRpbWVycygpIHtcbiAgY29uc3QgZGF0YSA9IHJlcXVpcmUoJ0BqZXN0L2Zha2UtdGltZXJzJyk7XG4gIF9mYWtlVGltZXJzID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBkYXRhO1xuICB9O1xuICByZXR1cm4gZGF0YTtcbn1cbmZ1bmN0aW9uIF9qZXN0TW9jaygpIHtcbiAgY29uc3QgZGF0YSA9IHJlcXVpcmUoJ2plc3QtbW9jaycpO1xuICBfamVzdE1vY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGRhdGE7XG4gIH07XG4gIHJldHVybiBkYXRhO1xufVxuZnVuY3Rpb24gX2plc3RVdGlsKCkge1xuICBjb25zdCBkYXRhID0gcmVxdWlyZSgnamVzdC11dGlsJyk7XG4gIF9qZXN0VXRpbCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZGF0YTtcbiAgfTtcbiAgcmV0dXJuIGRhdGE7XG59XG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuLy8gc29tZSBnbG9iYWxzIHdlIGRvIG5vdCB3YW50LCBlaXRoZXIgYmVjYXVzZSBkZXByZWNhdGVkIG9yIHdlIHNldCBpdCBvdXJzZWx2ZXNcbmNvbnN0IGRlbnlMaXN0ID0gbmV3IFNldChbXG4gICdHTE9CQUwnLFxuICAncm9vdCcsXG4gICdnbG9iYWwnLFxuICAnZ2xvYmFsVGhpcycsXG4gICdCdWZmZXInLFxuICAnQXJyYXlCdWZmZXInLFxuICAnVWludDhBcnJheScsXG4gIC8vIGlmIGVudiBpcyBsb2FkZWQgd2l0aGluIGEgamVzdCB0ZXN0XG4gICdqZXN0LXN5bWJvbC1kby1ub3QtdG91Y2gnXG5dKTtcbmNvbnN0IG5vZGVHbG9iYWxzID0gbmV3IE1hcChcbiAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoZ2xvYmFsVGhpcylcbiAgICAuZmlsdGVyKGdsb2JhbCA9PiAhZGVueUxpc3QuaGFzKGdsb2JhbCkpXG4gICAgLm1hcChub2RlR2xvYmFsc0tleSA9PiB7XG4gICAgICBjb25zdCBkZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihcbiAgICAgICAgZ2xvYmFsVGhpcyxcbiAgICAgICAgbm9kZUdsb2JhbHNLZXlcbiAgICAgICk7XG4gICAgICBpZiAoIWRlc2NyaXB0b3IpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBObyBwcm9wZXJ0eSBkZXNjcmlwdG9yIGZvciAke25vZGVHbG9iYWxzS2V5fSwgdGhpcyBpcyBhIGJ1ZyBpbiBKZXN0LmBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBbbm9kZUdsb2JhbHNLZXksIGRlc2NyaXB0b3JdO1xuICAgIH0pXG4pO1xuZnVuY3Rpb24gaXNTdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZyc7XG59XG5jbGFzcyBOb2RlRW52aXJvbm1lbnQge1xuICBjb250ZXh0O1xuICBmYWtlVGltZXJzO1xuICBmYWtlVGltZXJzTW9kZXJuO1xuICBnbG9iYWw7XG4gIG1vZHVsZU1vY2tlcjtcbiAgY3VzdG9tRXhwb3J0Q29uZGl0aW9ucyA9IFsnbm9kZScsICdub2RlLWFkZG9ucyddO1xuICBfY29uZmlndXJlZEV4cG9ydENvbmRpdGlvbnM7XG5cbiAgLy8gd2hpbGUgYGNvbnRleHRgIGlzIHVudXNlZCwgaXQgc2hvdWxkIGFsd2F5cyBiZSBwYXNzZWRcbiAgY29uc3RydWN0b3IoY29uZmlnLCBfY29udGV4dCkge1xuICAgIGNvbnN0IHtwcm9qZWN0Q29uZmlnfSA9IGNvbmZpZztcbiAgICB0aGlzLmNvbnRleHQgPSAoMCwgX3ZtKCkuY3JlYXRlQ29udGV4dCkoKTtcbiAgICBjb25zdCBnbG9iYWwgPSAoMCwgX3ZtKCkucnVuSW5Db250ZXh0KShcbiAgICAgICd0aGlzJyxcbiAgICAgIE9iamVjdC5hc3NpZ24odGhpcy5jb250ZXh0LCBwcm9qZWN0Q29uZmlnLnRlc3RFbnZpcm9ubWVudE9wdGlvbnMpXG4gICAgKTtcbiAgICB0aGlzLmdsb2JhbCA9IGdsb2JhbDtcbiAgICBjb25zdCBjb250ZXh0R2xvYmFscyA9IG5ldyBTZXQoT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoZ2xvYmFsKSk7XG4gICAgZm9yIChjb25zdCBbbm9kZUdsb2JhbHNLZXksIGRlc2NyaXB0b3JdIG9mIG5vZGVHbG9iYWxzKSB7XG4gICAgICBpZiAoIWNvbnRleHRHbG9iYWxzLmhhcyhub2RlR2xvYmFsc0tleSkpIHtcbiAgICAgICAgaWYgKGRlc2NyaXB0b3IuY29uZmlndXJhYmxlKSB7XG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGdsb2JhbCwgbm9kZUdsb2JhbHNLZXksIHtcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IGRlc2NyaXB0b3IuZW51bWVyYWJsZSxcbiAgICAgICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBnbG9iYWxUaGlzW25vZGVHbG9iYWxzS2V5XTtcblxuICAgICAgICAgICAgICAvLyBvdmVycmlkZSBsYXp5IGdldHRlclxuICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZ2xvYmFsLCBub2RlR2xvYmFsc0tleSwge1xuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBkZXNjcmlwdG9yLmVudW1lcmFibGUsXG4gICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXQodmFsdWUpIHtcbiAgICAgICAgICAgICAgLy8gb3ZlcnJpZGUgbGF6eSBnZXR0ZXJcbiAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGdsb2JhbCwgbm9kZUdsb2JhbHNLZXksIHtcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogZGVzY3JpcHRvci5lbnVtZXJhYmxlLFxuICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKCd2YWx1ZScgaW4gZGVzY3JpcHRvcikge1xuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShnbG9iYWwsIG5vZGVHbG9iYWxzS2V5LCB7XG4gICAgICAgICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgZW51bWVyYWJsZTogZGVzY3JpcHRvci5lbnVtZXJhYmxlLFxuICAgICAgICAgICAgdmFsdWU6IGRlc2NyaXB0b3IudmFsdWUsXG4gICAgICAgICAgICB3cml0YWJsZTogZGVzY3JpcHRvci53cml0YWJsZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShnbG9iYWwsIG5vZGVHbG9iYWxzS2V5LCB7XG4gICAgICAgICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgZW51bWVyYWJsZTogZGVzY3JpcHRvci5lbnVtZXJhYmxlLFxuICAgICAgICAgICAgZ2V0OiBkZXNjcmlwdG9yLmdldCxcbiAgICAgICAgICAgIHNldDogZGVzY3JpcHRvci5zZXRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgLSBCdWZmZXIgYW5kIGdjIGlzIFwibWlzc2luZ1wiXG4gICAgZ2xvYmFsLmdsb2JhbCA9IGdsb2JhbDtcbiAgICBnbG9iYWwuQnVmZmVyID0gQnVmZmVyO1xuICAgIGdsb2JhbC5BcnJheUJ1ZmZlciA9IEFycmF5QnVmZmVyO1xuICAgIC8vIFRleHRFbmNvZGVyIChnbG9iYWwgb3IgdmlhICd1dGlsJykgcmVmZXJlbmNlcyBhIFVpbnQ4QXJyYXkgY29uc3RydWN0b3JcbiAgICAvLyBkaWZmZXJlbnQgdGhhbiB0aGUgZ2xvYmFsIG9uZSB1c2VkIGJ5IHVzZXJzIGluIHRlc3RzLiBUaGlzIG1ha2VzIHN1cmUgdGhlXG4gICAgLy8gc2FtZSBjb25zdHJ1Y3RvciBpcyByZWZlcmVuY2VkIGJ5IGJvdGguXG4gICAgZ2xvYmFsLlVpbnQ4QXJyYXkgPSBVaW50OEFycmF5O1xuICAgICgwLCBfamVzdFV0aWwoKS5pbnN0YWxsQ29tbW9uR2xvYmFscykoZ2xvYmFsLCBwcm9qZWN0Q29uZmlnLmdsb2JhbHMpO1xuXG4gICAgLy8gTm9kZSdzIGVycm9yLW1lc3NhZ2Ugc3RhY2sgc2l6ZSBpcyBsaW1pdGVkIGF0IDEwLCBidXQgaXQncyBwcmV0dHkgdXNlZnVsXG4gICAgLy8gdG8gc2VlIG1vcmUgdGhhbiB0aGF0IHdoZW4gYSB0ZXN0IGZhaWxzLlxuICAgIGdsb2JhbC5FcnJvci5zdGFja1RyYWNlTGltaXQgPSAxMDA7XG4gICAgaWYgKCdjdXN0b21FeHBvcnRDb25kaXRpb25zJyBpbiBwcm9qZWN0Q29uZmlnLnRlc3RFbnZpcm9ubWVudE9wdGlvbnMpIHtcbiAgICAgIGNvbnN0IHtjdXN0b21FeHBvcnRDb25kaXRpb25zfSA9IHByb2plY3RDb25maWcudGVzdEVudmlyb25tZW50T3B0aW9ucztcbiAgICAgIGlmIChcbiAgICAgICAgQXJyYXkuaXNBcnJheShjdXN0b21FeHBvcnRDb25kaXRpb25zKSAmJlxuICAgICAgICBjdXN0b21FeHBvcnRDb25kaXRpb25zLmV2ZXJ5KGlzU3RyaW5nKVxuICAgICAgKSB7XG4gICAgICAgIHRoaXMuX2NvbmZpZ3VyZWRFeHBvcnRDb25kaXRpb25zID0gY3VzdG9tRXhwb3J0Q29uZGl0aW9ucztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAnQ3VzdG9tIGV4cG9ydCBjb25kaXRpb25zIHNwZWNpZmllZCBidXQgdGhleSBhcmUgbm90IGFuIGFycmF5IG9mIHN0cmluZ3MnXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMubW9kdWxlTW9ja2VyID0gbmV3IChfamVzdE1vY2soKS5Nb2R1bGVNb2NrZXIpKGdsb2JhbCk7XG4gICAgY29uc3QgdGltZXJJZFRvUmVmID0gaWQgPT4gKHtcbiAgICAgIGlkLFxuICAgICAgcmVmKCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG4gICAgICB1bnJlZigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgfSk7XG4gICAgY29uc3QgdGltZXJSZWZUb0lkID0gdGltZXIgPT4gdGltZXI/LmlkO1xuICAgIHRoaXMuZmFrZVRpbWVycyA9IG5ldyAoX2Zha2VUaW1lcnMoKS5MZWdhY3lGYWtlVGltZXJzKSh7XG4gICAgICBjb25maWc6IHByb2plY3RDb25maWcsXG4gICAgICBnbG9iYWwsXG4gICAgICBtb2R1bGVNb2NrZXI6IHRoaXMubW9kdWxlTW9ja2VyLFxuICAgICAgdGltZXJDb25maWc6IHtcbiAgICAgICAgaWRUb1JlZjogdGltZXJJZFRvUmVmLFxuICAgICAgICByZWZUb0lkOiB0aW1lclJlZlRvSWRcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLmZha2VUaW1lcnNNb2Rlcm4gPSBuZXcgKF9mYWtlVGltZXJzKCkuTW9kZXJuRmFrZVRpbWVycykoe1xuICAgICAgY29uZmlnOiBwcm9qZWN0Q29uZmlnLFxuICAgICAgZ2xvYmFsXG4gICAgfSk7XG4gIH1cblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWVtcHR5LWZ1bmN0aW9uXG4gIGFzeW5jIHNldHVwKCkge31cbiAgYXN5bmMgdGVhcmRvd24oKSB7XG4gICAgaWYgKHRoaXMuZmFrZVRpbWVycykge1xuICAgICAgdGhpcy5mYWtlVGltZXJzLmRpc3Bvc2UoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuZmFrZVRpbWVyc01vZGVybikge1xuICAgICAgdGhpcy5mYWtlVGltZXJzTW9kZXJuLmRpc3Bvc2UoKTtcbiAgICB9XG4gICAgdGhpcy5jb250ZXh0ID0gbnVsbDtcbiAgICB0aGlzLmZha2VUaW1lcnMgPSBudWxsO1xuICAgIHRoaXMuZmFrZVRpbWVyc01vZGVybiA9IG51bGw7XG4gIH1cbiAgZXhwb3J0Q29uZGl0aW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5fY29uZmlndXJlZEV4cG9ydENvbmRpdGlvbnMgPz8gdGhpcy5jdXN0b21FeHBvcnRDb25kaXRpb25zO1xuICB9XG4gIGdldFZtQ29udGV4dCgpIHtcbiAgICByZXR1cm4gdGhpcy5jb250ZXh0O1xuICB9XG59XG5leHBvcnRzLmRlZmF1bHQgPSBOb2RlRW52aXJvbm1lbnQ7XG5jb25zdCBUZXN0RW52aXJvbm1lbnQgPSBOb2RlRW52aXJvbm1lbnQ7XG5leHBvcnRzLlRlc3RFbnZpcm9ubWVudCA9IFRlc3RFbnZpcm9ubWVudDtcbiJdLCJtYXBwaW5ncyI6IkFBQUEsWUFBWTs7QUFFWkEsTUFBTSxDQUFDQyxjQUFjLENBQUNDLE9BQU8sRUFBRSxZQUFZLEVBQUU7RUFDM0NDLEtBQUssRUFBRTtBQUNULENBQUMsQ0FBQztBQUNGRCxPQUFPLENBQUNFLE9BQU8sR0FBR0YsT0FBTyxDQUFDRyxlQUFlLEdBQUcsS0FBSyxDQUFDO0FBQ2xELFNBQVNDLEdBQUdBLENBQUEsRUFBRztFQUNiLE1BQU1DLElBQUksR0FBR0MsT0FBTyxDQUFDLElBQUksQ0FBQztFQUMxQkYsR0FBRyxHQUFHLFNBQUFBLENBQUEsRUFBWTtJQUNoQixPQUFPQyxJQUFJO0VBQ2IsQ0FBQztFQUNELE9BQU9BLElBQUk7QUFDYjtBQUNBLFNBQVNFLFdBQVdBLENBQUEsRUFBRztFQUNyQixNQUFNRixJQUFJLEdBQUdDLE9BQU8sQ0FBQyxtQkFBbUIsQ0FBQztFQUN6Q0MsV0FBVyxHQUFHLFNBQUFBLENBQUEsRUFBWTtJQUN4QixPQUFPRixJQUFJO0VBQ2IsQ0FBQztFQUNELE9BQU9BLElBQUk7QUFDYjtBQUNBLFNBQVNHLFNBQVNBLENBQUEsRUFBRztFQUNuQixNQUFNSCxJQUFJLEdBQUdDLE9BQU8sQ0FBQyxXQUFXLENBQUM7RUFDakNFLFNBQVMsR0FBRyxTQUFBQSxDQUFBLEVBQVk7SUFDdEIsT0FBT0gsSUFBSTtFQUNiLENBQUM7RUFDRCxPQUFPQSxJQUFJO0FBQ2I7QUFDQSxTQUFTSSxTQUFTQSxDQUFBLEVBQUc7RUFDbkIsTUFBTUosSUFBSSxHQUFHQyxPQUFPLENBQUMsV0FBVyxDQUFDO0VBQ2pDRyxTQUFTLEdBQUcsU0FBQUEsQ0FBQSxFQUFZO0lBQ3RCLE9BQU9KLElBQUk7RUFDYixDQUFDO0VBQ0QsT0FBT0EsSUFBSTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTUssUUFBUSxHQUFHLElBQUlDLEdBQUcsQ0FBQyxDQUN2QixRQUFRLEVBQ1IsTUFBTSxFQUNOLFFBQVEsRUFDUixZQUFZLEVBQ1osUUFBUSxFQUNSLGFBQWEsRUFDYixZQUFZO0FBQ1o7QUFDQSwwQkFBMEIsQ0FDM0IsQ0FBQztBQUNGLE1BQU1DLFdBQVcsR0FBRyxJQUFJQyxHQUFHLENBQ3pCZixNQUFNLENBQUNnQixtQkFBbUIsQ0FBQ0MsVUFBVSxDQUFDLENBQ25DQyxNQUFNLENBQUNDLE1BQU0sSUFBSSxDQUFDUCxRQUFRLENBQUNRLEdBQUcsQ0FBQ0QsTUFBTSxDQUFDLENBQUMsQ0FDdkNFLEdBQUcsQ0FBQ0MsY0FBYyxJQUFJO0VBQ3JCLE1BQU1DLFVBQVUsR0FBR3ZCLE1BQU0sQ0FBQ3dCLHdCQUF3QixDQUNoRFAsVUFBVSxFQUNWSyxjQUNGLENBQUM7RUFDRCxJQUFJLENBQUNDLFVBQVUsRUFBRTtJQUNmLE1BQU0sSUFBSUUsS0FBSyxDQUNiLDhCQUE4QkgsY0FBYywwQkFDOUMsQ0FBQztFQUNIO0VBQ0EsT0FBTyxDQUFDQSxjQUFjLEVBQUVDLFVBQVUsQ0FBQztBQUNyQyxDQUFDLENBQ0wsQ0FBQztBQUNELFNBQVNHLFFBQVFBLENBQUN2QixLQUFLLEVBQUU7RUFDdkIsT0FBTyxPQUFPQSxLQUFLLEtBQUssUUFBUTtBQUNsQztBQUNBLE1BQU13QixlQUFlLENBQUM7RUFDcEJDLE9BQU87RUFDUEMsVUFBVTtFQUNWQyxnQkFBZ0I7RUFDaEJYLE1BQU07RUFDTlksWUFBWTtFQUNaQyxzQkFBc0IsR0FBRyxDQUFDLE1BQU0sRUFBRSxhQUFhLENBQUM7RUFDaERDLDJCQUEyQjs7RUFFM0I7RUFDQUMsV0FBV0EsQ0FBQ0MsTUFBTSxFQUFFQyxRQUFRLEVBQUU7SUFDNUIsTUFBTTtNQUFDQztJQUFhLENBQUMsR0FBR0YsTUFBTTtJQUM5QixJQUFJLENBQUNQLE9BQU8sR0FBRyxDQUFDLENBQUMsRUFBRXRCLEdBQUcsQ0FBQyxDQUFDLENBQUNnQyxhQUFhLEVBQUUsQ0FBQztJQUN6QyxNQUFNbkIsTUFBTSxHQUFHLENBQUMsQ0FBQyxFQUFFYixHQUFHLENBQUMsQ0FBQyxDQUFDaUMsWUFBWSxFQUNuQyxNQUFNLEVBQ052QyxNQUFNLENBQUN3QyxNQUFNLENBQUMsSUFBSSxDQUFDWixPQUFPLEVBQUVTLGFBQWEsQ0FBQ0ksc0JBQXNCLENBQ2xFLENBQUM7SUFDRCxJQUFJLENBQUN0QixNQUFNLEdBQUdBLE1BQU07SUFDcEIsTUFBTXVCLGNBQWMsR0FBRyxJQUFJN0IsR0FBRyxDQUFDYixNQUFNLENBQUNnQixtQkFBbUIsQ0FBQ0csTUFBTSxDQUFDLENBQUM7SUFDbEUsS0FBSyxNQUFNLENBQUNHLGNBQWMsRUFBRUMsVUFBVSxDQUFDLElBQUlULFdBQVcsRUFBRTtNQUN0RCxJQUFJLENBQUM0QixjQUFjLENBQUN0QixHQUFHLENBQUNFLGNBQWMsQ0FBQyxFQUFFO1FBQ3ZDLElBQUlDLFVBQVUsQ0FBQ29CLFlBQVksRUFBRTtVQUMzQjNDLE1BQU0sQ0FBQ0MsY0FBYyxDQUFDa0IsTUFBTSxFQUFFRyxjQUFjLEVBQUU7WUFDNUNxQixZQUFZLEVBQUUsSUFBSTtZQUNsQkMsVUFBVSxFQUFFckIsVUFBVSxDQUFDcUIsVUFBVTtZQUNqQ0MsR0FBR0EsQ0FBQSxFQUFHO2NBQ0osTUFBTTFDLEtBQUssR0FBR2MsVUFBVSxDQUFDSyxjQUFjLENBQUM7O2NBRXhDO2NBQ0F0QixNQUFNLENBQUNDLGNBQWMsQ0FBQ2tCLE1BQU0sRUFBRUcsY0FBYyxFQUFFO2dCQUM1Q3FCLFlBQVksRUFBRSxJQUFJO2dCQUNsQkMsVUFBVSxFQUFFckIsVUFBVSxDQUFDcUIsVUFBVTtnQkFDakN6QyxLQUFLO2dCQUNMMkMsUUFBUSxFQUFFO2NBQ1osQ0FBQyxDQUFDO2NBQ0YsT0FBTzNDLEtBQUs7WUFDZCxDQUFDO1lBQ0Q0QyxHQUFHQSxDQUFDNUMsS0FBSyxFQUFFO2NBQ1Q7Y0FDQUgsTUFBTSxDQUFDQyxjQUFjLENBQUNrQixNQUFNLEVBQUVHLGNBQWMsRUFBRTtnQkFDNUNxQixZQUFZLEVBQUUsSUFBSTtnQkFDbEJDLFVBQVUsRUFBRXJCLFVBQVUsQ0FBQ3FCLFVBQVU7Z0JBQ2pDekMsS0FBSztnQkFDTDJDLFFBQVEsRUFBRTtjQUNaLENBQUMsQ0FBQztZQUNKO1VBQ0YsQ0FBQyxDQUFDO1FBQ0osQ0FBQyxNQUFNLElBQUksT0FBTyxJQUFJdkIsVUFBVSxFQUFFO1VBQ2hDdkIsTUFBTSxDQUFDQyxjQUFjLENBQUNrQixNQUFNLEVBQUVHLGNBQWMsRUFBRTtZQUM1Q3FCLFlBQVksRUFBRSxLQUFLO1lBQ25CQyxVQUFVLEVBQUVyQixVQUFVLENBQUNxQixVQUFVO1lBQ2pDekMsS0FBSyxFQUFFb0IsVUFBVSxDQUFDcEIsS0FBSztZQUN2QjJDLFFBQVEsRUFBRXZCLFVBQVUsQ0FBQ3VCO1VBQ3ZCLENBQUMsQ0FBQztRQUNKLENBQUMsTUFBTTtVQUNMOUMsTUFBTSxDQUFDQyxjQUFjLENBQUNrQixNQUFNLEVBQUVHLGNBQWMsRUFBRTtZQUM1Q3FCLFlBQVksRUFBRSxLQUFLO1lBQ25CQyxVQUFVLEVBQUVyQixVQUFVLENBQUNxQixVQUFVO1lBQ2pDQyxHQUFHLEVBQUV0QixVQUFVLENBQUNzQixHQUFHO1lBQ25CRSxHQUFHLEVBQUV4QixVQUFVLENBQUN3QjtVQUNsQixDQUFDLENBQUM7UUFDSjtNQUNGO0lBQ0Y7O0lBRUE7SUFDQTVCLE1BQU0sQ0FBQ0EsTUFBTSxHQUFHQSxNQUFNO0lBQ3RCQSxNQUFNLENBQUM2QixNQUFNLEdBQUdBLE1BQU07SUFDdEI3QixNQUFNLENBQUM4QixXQUFXLEdBQUdBLFdBQVc7SUFDaEM7SUFDQTtJQUNBO0lBQ0E5QixNQUFNLENBQUMrQixVQUFVLEdBQUdBLFVBQVU7SUFDOUIsQ0FBQyxDQUFDLEVBQUV2QyxTQUFTLENBQUMsQ0FBQyxDQUFDd0Msb0JBQW9CLEVBQUVoQyxNQUFNLEVBQUVrQixhQUFhLENBQUNlLE9BQU8sQ0FBQzs7SUFFcEU7SUFDQTtJQUNBakMsTUFBTSxDQUFDTSxLQUFLLENBQUM0QixlQUFlLEdBQUcsR0FBRztJQUNsQyxJQUFJLHdCQUF3QixJQUFJaEIsYUFBYSxDQUFDSSxzQkFBc0IsRUFBRTtNQUNwRSxNQUFNO1FBQUNUO01BQXNCLENBQUMsR0FBR0ssYUFBYSxDQUFDSSxzQkFBc0I7TUFDckUsSUFDRWEsS0FBSyxDQUFDQyxPQUFPLENBQUN2QixzQkFBc0IsQ0FBQyxJQUNyQ0Esc0JBQXNCLENBQUN3QixLQUFLLENBQUM5QixRQUFRLENBQUMsRUFDdEM7UUFDQSxJQUFJLENBQUNPLDJCQUEyQixHQUFHRCxzQkFBc0I7TUFDM0QsQ0FBQyxNQUFNO1FBQ0wsTUFBTSxJQUFJUCxLQUFLLENBQ2IseUVBQ0YsQ0FBQztNQUNIO0lBQ0Y7SUFDQSxJQUFJLENBQUNNLFlBQVksR0FBRyxLQUFLckIsU0FBUyxDQUFDLENBQUMsQ0FBQytDLFlBQVksRUFBRXRDLE1BQU0sQ0FBQztJQUMxRCxNQUFNdUMsWUFBWSxHQUFHQyxFQUFFLEtBQUs7TUFDMUJBLEVBQUU7TUFDRkMsR0FBR0EsQ0FBQSxFQUFHO1FBQ0osT0FBTyxJQUFJO01BQ2IsQ0FBQztNQUNEQyxLQUFLQSxDQUFBLEVBQUc7UUFDTixPQUFPLElBQUk7TUFDYjtJQUNGLENBQUMsQ0FBQztJQUNGLE1BQU1DLFlBQVksR0FBR0MsS0FBSyxJQUFJQSxLQUFLLEVBQUVKLEVBQUU7SUFDdkMsSUFBSSxDQUFDOUIsVUFBVSxHQUFHLEtBQUtwQixXQUFXLENBQUMsQ0FBQyxDQUFDdUQsZ0JBQWdCLEVBQUU7TUFDckQ3QixNQUFNLEVBQUVFLGFBQWE7TUFDckJsQixNQUFNO01BQ05ZLFlBQVksRUFBRSxJQUFJLENBQUNBLFlBQVk7TUFDL0JrQyxXQUFXLEVBQUU7UUFDWEMsT0FBTyxFQUFFUixZQUFZO1FBQ3JCUyxPQUFPLEVBQUVMO01BQ1g7SUFDRixDQUFDLENBQUM7SUFDRixJQUFJLENBQUNoQyxnQkFBZ0IsR0FBRyxLQUFLckIsV0FBVyxDQUFDLENBQUMsQ0FBQzJELGdCQUFnQixFQUFFO01BQzNEakMsTUFBTSxFQUFFRSxhQUFhO01BQ3JCbEI7SUFDRixDQUFDLENBQUM7RUFDSjs7RUFFQTtFQUNBLE1BQU1rRCxLQUFLQSxDQUFBLEVBQUcsQ0FBQztFQUNmLE1BQU1DLFFBQVFBLENBQUEsRUFBRztJQUNmLElBQUksSUFBSSxDQUFDekMsVUFBVSxFQUFFO01BQ25CLElBQUksQ0FBQ0EsVUFBVSxDQUFDMEMsT0FBTyxDQUFDLENBQUM7SUFDM0I7SUFDQSxJQUFJLElBQUksQ0FBQ3pDLGdCQUFnQixFQUFFO01BQ3pCLElBQUksQ0FBQ0EsZ0JBQWdCLENBQUN5QyxPQUFPLENBQUMsQ0FBQztJQUNqQztJQUNBLElBQUksQ0FBQzNDLE9BQU8sR0FBRyxJQUFJO0lBQ25CLElBQUksQ0FBQ0MsVUFBVSxHQUFHLElBQUk7SUFDdEIsSUFBSSxDQUFDQyxnQkFBZ0IsR0FBRyxJQUFJO0VBQzlCO0VBQ0EwQyxnQkFBZ0JBLENBQUEsRUFBRztJQUNqQixPQUFPLElBQUksQ0FBQ3ZDLDJCQUEyQixJQUFJLElBQUksQ0FBQ0Qsc0JBQXNCO0VBQ3hFO0VBQ0F5QyxZQUFZQSxDQUFBLEVBQUc7SUFDYixPQUFPLElBQUksQ0FBQzdDLE9BQU87RUFDckI7QUFDRjtBQUNBMUIsT0FBTyxDQUFDRSxPQUFPLEdBQUd1QixlQUFlO0FBQ2pDLE1BQU10QixlQUFlLEdBQUdzQixlQUFlO0FBQ3ZDekIsT0FBTyxDQUFDRyxlQUFlLEdBQUdBLGVBQWUiLCJpZ25vcmVMaXN0IjpbXX0=